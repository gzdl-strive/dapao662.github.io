---
title: 13--16例子
date: 2020-10-31 18:23:30
tag: js
---

### 13、函数柯里化
>指的是将一个接受多个参数的函数 变为 接受一个参数返回一个函数的固定形式，这样便于再次调用，例如f(1)(2)
经典面试题：实现`add(1)(2)(3)(4)=10;` 、 `add(1)(1,2,3)(2)=9;`
```js
function add() {
    const _args = [...arguments];
    function fn() {
        _args.push(...arguments);
        return fn;
    }
    fn.toString = function() {
        return _args.reduce((sum, cur) => sum + cur);
    }
    return fn;
}
```

### 14、模拟new操作
    **3个步骤**:
    1. 以`ctor.prototype`为原型创建一个对象.
    2. 执行构造函数并将this绑定到新创建的对象上.
    3. 判断构造函数执行返回的结果是否是引用数据类型，若是则返回返回构造函数执行的结果，否则返回创建的对象.

```js
function newOperator(ctor, ...args) {
    if(typeof ctor !== 'function') {
        throw new TypeError('Type Error');
    }
    const obj = Object.create(ctor.prototype);
    const res = ctor.apply(obj, args);

    const isObject = typeof res === 'Object' && res !== null;
    const isFunction = typeof res === 'function';
    return isObject || isFunction ? res : obj;
}
```


### 15、instanceof

>`instanceof`运算符用于检测构造函数的`prototype`属性是否出现在某个实例对象的原型链上。

```js
const myInstanceof = (left, right) => {
    //基本数据类型都返回false
    if (typeof left !== 'object' || left === null) {
        return false;
    }
    let proto = Object.getPrototypeOf(left);
    while(true) {
        if (proto === null) {
            return false;
        }
        if (proto === right.prototype) {
            return true;
        }
        proto = Object.getPrototypeOf(proto);
    }
}
```

### 16、原型继承
>这里只写寄生组合继承了，中间还有几个演变过来的继承但都有一些缺陷

```js
function Parent() {
    this.name = 'parent';
}
function Child() {
    Parent.call(this);
    this.type = 'children';
}
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
```
