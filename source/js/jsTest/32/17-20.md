---
title: 17--20例子
date: 2020-10-31 19:54:30
tag: js
---

### 17、Object.is

`Object.is`解决的主要是这两个问题：
```js
+0 === -0 //true
NaN === NaN //false

const is = (x, y) => {
    if (x === y) {
        // +0 和 -0应该不相等
        return x !== 0 || y !== 0 || 1/x === 1/y;
    } else {
        return x !== x && y !== y;
    }
}
```

### 18、Object.assign
>`Object.assign()`方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象（请注意这个操作是浅拷贝）

```js
Object.defineProperty(Object, 'assign', {
    value: function(target, ...args) {
        if (target == null) {
            return new TypeError('Cannot convert undefined or null to Object');
        }

        // 目标对象需要统一是引用数据类型，若不是会自动转换
        const to = Object(target);

        for(let i = 0; i < args.length; i++) {
            //每一个源对象
            const nextSource = args[i];
            if (nextSouce !== null) {
                // 使用for...in和hasOwnProperty双重判断，确保只拿到本身的属性、方法（不包含继承的）
                for (const nextKey in nextSource) {
                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        return to;
    },
    //不可枚举
    enumerable: false,
    writable: true,
    configurable: true,
})
```

### 19、深拷贝
>递归的完整版本（考虑到了Symbol属性）：

```js
const cloneDeep1 = (target, hash = new WeakMap()) => {
    //对于传入参数处理
    if (typeof target !== 'object' || target === null) {
        return target;
    }
    //哈希表中存在直接返回
    if (hash.has(target)) {
        return hash.get(target);
    }

    const cloneTarget = Array.isArray(target) ? [] : {};
    hash.set(target, cloneTarget);

    //针对Symbol属性
    const symKeys = Object.getOwnPropertySymbols(target);
    if (symKeys.length) {
        symKeys.forEach(symKey => {
            if (typeof target[symKey] === 'object' && target[symKey] !== null) {
                cloneTarget[symKey] = cloneDeep1(target[symKey]);
            } else {
                cloneTarget[symKey] = target[symKey];
            }
        })
    }

    for (const i in target) {
        if (Object.prototype.hasOwnProperty.call(target, i)) {
            cloneTarget[i] = typeof target[i] === 'object' && target[i] !== null ? cloneDeep1(target[i], hash) :target[i];
        }
    }
    return cloneTarget;
}
```

### 20、Promise

```javascript
const PENDING = 'PENDING';      // 进行中
const FULFILLED = 'FULFILLED';  // 已成功
const REJECTED = 'REJECTED';    // 已失败

class Promise {
  constructor(exector) {
    // 初始化状态
    this.status = PENDING;
    // 将成功、失败结果放在this上，便于then、catch访问
    this.value = undefined;
    this.reason = undefined;
    // 成功态回调函数队列
    this.onFulfilledCallbacks = [];
    // 失败态回调函数队列
    this.onRejectedCallbacks = [];

    const resolve = value => {
      // 只有进行中状态才能更改状态
      if (this.status === PENDING) {
        this.status = FULFILLED;
        this.value = value;
        // 成功态函数依次执行
        this.onFulfilledCallbacks.forEach(fn => fn(this.value));
      }
    }
    const reject = reason => {
      // 只有进行中状态才能更改状态
      if (this.status === PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        // 失败态函数依次执行
        this.onRejectedCallbacks.forEach(fn => fn(this.reason))
      }
    }
    try {
      // 立即执行executor
      // 把内部的resolve和reject传入executor，用户可调用resolve和reject
      exector(resolve, reject);
    } catch(e) {
      // executor执行出错，将错误内容reject抛出去
      reject(e);
    }
  }
  then(onFulfilled, onRejected) {
    //解决值穿透问题（then的参数不是函数的情况下会发生值穿透）
    //then参数期望是函数，传入非函数则会发生值穿透。值传透可以理解为，当传入then的不是函数的时候，这个then是无效的。
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function'? onRejected:
      reason => { throw new Error(reason instanceof Error ? reason.message:reason) }
    // 保存this
    const self = this;
    return new Promise((resolve, reject) => {
      if (self.status === PENDING) {
        self.onFulfilledCallbacks.push(() => {
          // try捕获错误
          try {
            // 模拟微任务
            setTimeout(() => {
              const result = onFulfilled(self.value);
              // 分两种情况：
              // 1. 回调函数返回值是Promise，执行then操作
              // 2. 如果不是Promise，调用新Promise的resolve函数
              result instanceof Promise ? result.then(resolve, reject) : resolve(result);
            })
          } catch(e) {
            reject(e);
          }
        });
        self.onRejectedCallbacks.push(() => {
          // 以下同理
          try {
            setTimeout(() => {
              const result = onRejected(self.reason);
              // 不同点：此时是reject
              result instanceof Promise ? result.then(resolve, reject) : reject(result);
            })
          } catch(e) {
            reject(e);
          }
        })
      } else if (self.status === FULFILLED) {
        try {
          setTimeout(() => {
            const result = onFulfilled(self.value);
            result instanceof Promise ? result.then(resolve, reject) : resolve(result);
          });
        } catch(e) {
          reject(e);
        }
      } else if (self.status === REJECTED){
        try {
          setTimeout(() => {
            const result = onRejected(self.reason);
            result instanceof Promise ? result.then(resolve, reject) : reject(result);
          })
        } catch(e) {
          reject(e);
        }
      }
    });
  }
  //Promise.prototype.catch就是Promise.prototype.then(null, onRejected)的别名
  catch(onRejected) {
    return this.then(null, onRejected);
  }
  static resolve(value) {
    if (value instanceof Promise) {
      // 如果是Promise实例，直接返回
      return value;
    } else {
      // 如果不是Promise实例，返回一个新的Promise对象，状态为FULFILLED
      return new Promise((resolve, reject) => resolve(value));
    }
  }
  static reject(reason) {
    return new Promise((resolve, reject) => {
      reject(reason);
    })
  }
}
```

