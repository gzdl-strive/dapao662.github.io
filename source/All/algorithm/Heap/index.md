---
title: 堆和优先队列
date: 2021-07-30 16:30:24
toc: true
---

## 堆和优先队列笔记
>[笔记](/All/algorithm/Heap/know "堆和优先队列笔记")

## 堆的封装实现
>[封装堆](/All/algorithm/Heap/package "封装堆")

## 堆练习
### 堆的基础应用
>剑指Offer40 最小的k个数(维护一个大顶堆，遍历给定的数组，当堆大小小于k时，直接加入堆中，如果堆大小大于k，我们就从堆中弹出堆顶元素，因为我们创建的是一个大顶堆，所以每次弹出的都是堆中最大的元素，所以堆中剩下的就是最小的k个数)
**思路：我们可以知道，要取最小的k个数，也就是说，我们想要进入到最小的k个数里面去，只需要满足比最小k个数中最大的数小就行，所以，我们可以维护一个大顶堆**
>#LeetCode 1046 最后一块石头的重量(题意中描述：每次取最重的两块石头，所以我们可以维护一个大顶堆)
>#LeetCode 703 数据流中的第k大元素(要取第k大元素，也就是说想要进入到前k个最大元素，只需要满足比最大k个元素中最小的数大就行，所以，我们可以维护一个小顶堆)
>#LeetCode 373 查找和最小的k对数字(和最小，和之前一样，我们可以定义一个大顶堆)
>#LeetCode 215 数组中的第k个最大元素(和数据流中的第k大元素一样，维护一个小顶堆即可)

### 堆的进阶应用
>#LeetCode 692 前k个高频单词(解题关键在于不仅使用一个小顶堆来存，还需要兼顾当个数一致时，不同单词之间的比较)
>#LeetCode 面试题17.20.连续中值(解题关键在于中位数位置，我们可以创建两个堆，使用一个大顶堆存储前半部分，使用小顶堆存储后半部分)
>#LeetCode 295 数据流的中位数(和上一题一样)
>#LeetCode 1801 积压订单中的订单总数（利用堆，根据题意，使用一个大顶堆存储采购订单，一个小顶堆存储销售订单）

### 智力发散题
>#LeetCode 264 丑数II（和之前做的面试题17.09 第k个数一样，只是质数不同而已，可以和之前使用同一样的方法：设置三个变量，用来记录每个素因子的使用次数，然后变量k次，每次进行素因子相乘，取最小值。  方法二：可以使用一个小顶堆用于存储当前最小变量，然后判断当前最小数的最大素因子是谁(2,3,5),(例如5，我们只要把它乘以5在加入数组即可， 如果是3的话，就要推入最小变量 * 3， 最小变量 * 5)）
>#LeetCode 313 超级丑数(和丑数II的做法一样，只不过现在素因子不再是固定的了，需要我们遍历(所以哦我们可以创建一个数组用于存放素因子，每个元素代表结果集中的下标))
>#LeetCode 1753 移除石子的最大得分(先把三堆石子排序，首先干掉第一堆里面，第三根堆比第二堆长的数量。接着判断第一堆里面是否为0，如果为0了，之间加上第二堆的数量即可，如果不为0，那么第二堆和第三堆的数量就是一致的，分别消掉第一堆数量的一半，此时第一堆已经被消掉了，然后我们不断减掉第二堆和第三堆的数量即可)
